<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Mime - The Mime API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.8.0pr2/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <script src="http://yui.yahooapis.com/combo?3.8.0pr2/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            <h1><a href="../index.html">The Mime API: Mime</a></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.3</em>
        </div>
    </div>
    <div class="yui3-g">

        <div id="sidebar" class="yui3-u">
            <div id="modules" class="sidebox">
    <div class="hd">
        <h2 class="no-toc">Modules</h2>
    </div>
    <div class="bd">
        <ul>
            
                <li><a href="../modules/Mime.html">Mime</a>
                
                </li>
            
        </ul>
    </div>
</div>

<div id="classes" class="sidebox">
    <div class="hd">
        <h2 class="no-toc">Classes</h2>
    </div>
    <div class="bd">
        <ul>
            
                <li><a href="../classes/Mime.html">Mime</a></li>
            
                <li><a href="../classes/safeObject.html">safeObject</a></li>
            
        </ul>
    </div>
</div>


<div id="methods-on-page" class="sidebox on-page">
    <div class="hd">
        <h2 class="no-toc">Methods On Page</h2>
    </div>
    <div class="bd">
        <ul>
            
                <li><a href="#methods___logCall">__logCall</a></li>
            
                <li><a href="#methods___undefinedMethod__">__undefinedMethod__</a></li>
            
                <li><a href="#methods__createClass">_createClass</a></li>
            
                <li><a href="#methods__getAllCallArguments">_getAllCallArguments</a></li>
            
                <li><a href="#methods__getCallArguments">_getCallArguments</a></li>
            
                <li><a href="#methods__mockModule">_mockModule</a></li>
            
                <li><a href="#methods__spy">_spy</a></li>
            
                <li><a href="#methods__unmockModule">_unmockModule</a></li>
            
                <li><a href="#methods__wasCalledWithArguments">_wasCalledWithArguments</a></li>
            
                <li><a href="#methods_require">require</a></li>
            
        </ul>
    </div>
</div>









<div id="fileTree" class="sidebox">
    <div class="hd">
        <h2 class="no-toc">Files</h2>
    </div>
    <div class="bd">
        <ul><li>mime/<ul><li><a href="../files/mime_mime.js.html">mime.js</a></li></ul></li></ul>
    </div>
</div>



        </div>

        <div id="main" class="yui3-u">
            <div class="content"><span class="foundat">Class defined in: <a href="../files/mime_mime.js.html#l96"><code>mime&#x2F;mime.js:96</code></a></span><h2>Mime Class</h2>




<div class="intro"><p>Mime constructor. Takes an optional argument that implements a deepEqual
comparison to be able to determine whether the arguments passed into the
function call are equal. By default it uses the Node.js assert.deepEqual.
You will want to override this if you have objects that do not serialize
naturally</p>
</div>


    <h3>Constructor</h3>
    
    <a name="methods_Mime"></a>
<div class="method item">
    <span class="foundat">
    
        
    
        <a href="../files/mime_mime.js.html#l96"><code>mime&#x2F;mime.js:96</code></a>
    </span>
    <h4 class="name"><span><code>Mime</code></span>( <code>[f] </code> ) </h4>
    <br>
    
    
    <h5>Parameters:</h5>
    <ul class="params">
    
        <li>
        
            <code>[f]</code> <strong>&lt;Function&gt;</strong>
        
        
        <p>a deepEqual function that can be used to compare whether two object structures are equal</p>

            
        </li>
    
    </ul>
    
    
    
    <br><div class="returns"><strong>Returns:</strong> &lt;Undefined&gt; </div>
    
    
    
</div>

    


<div id="classdocs">
    <ul>
        
        <li><a href="#methods">Methods</a></li>
        
        
        
        
    </ul>
    <div>
        
            <div id="methods">
            
                <a name="methods___logCall"></a>
<div class="method item private">
    <span class="foundat">
    
        
    
        <a href="../files/mime_mime.js.html#l152"><code>mime&#x2F;mime.js:152</code></a>
    </span>
    <h4 class="name"><span><code>__logCall</code></span>( <code>name, [restOfArguments] </code> ) <em><code>&#x2F;* private method *&#x2F;</code></em></h4>
    <br>
    <p>Log a call to a function</p>

    
    <h5>Parameters:</h5>
    <ul class="params">
    
        <li>
        
            <code>name</code> <strong>&lt;String&gt;</strong>
        
        
        <ul>
<li>the name of the function</li>
</ul>

            
        </li>
    
        <li>
        
            <code>[restOfArguments]</code> <strong>&lt;Array&gt;</strong>
        
        
        <ul>
<li>the argument array</li>
</ul>

            
        </li>
    
    </ul>
    
    
    
    <br><div class="returns"><strong>Returns:</strong> &lt;Undefined&gt; </div>
    
    
    
</div>

            
                <a name="methods___undefinedMethod__"></a>
<div class="method item private">
    <span class="foundat">
    
        
    
        <a href="../files/mime_mime.js.html#l135"><code>mime&#x2F;mime.js:135</code></a>
    </span>
    <h4 class="name"><span><code>__undefinedMethod__</code></span>( <code>  </code> ) <em><code>&#x2F;* private method *&#x2F;</code></em></h4>
    <br>
    <p>Internal method that captures calls to undefined functions into the log
structure</p>

    
    
    
    <br><div class="returns"><strong>Returns:</strong> &lt;Undefined&gt; </div>
    
    
    
</div>

            
                <a name="methods__createClass"></a>
<div class="method item">
    <span class="foundat">
    
        
    
        <a href="../files/mime_mime.js.html#l442"><code>mime&#x2F;mime.js:442</code></a>
    </span>
    <h4 class="name"><span><code>_createClass</code></span>( <code>constructor </code> ) </h4>
    <br>
    <p>Given a constructor function as an argument, create a new Class that inherits from
the Mime class but whose instances&#39; cal logs are shared with this instance&#39;s call log.
This is useful when mocking a global or require class so that access can be gained to
what happens to the instances of that class.
The call log will also log the creation of instances under the symbol &#39;Class&#39;, so that
the arguments to those calls can also be captured</p>

    
    <h5>Parameters:</h5>
    <ul class="params">
    
        <li>
        
            <code>constructor</code> <strong>&lt;Function&gt;</strong>
        
        
        <ul>
<li>the constructor function</li>
</ul>

            
        </li>
    
    </ul>
    
    
    
    <br><div class="returns"><strong>Returns:</strong> &lt;Function&gt; <ul>
<li>the inherited and bound constructor</li>
</ul>
</div>
    
    
    
        <h5>Example</h5>
        <pre class="code prettyprint"><code>   var assert = require(&#39;assert&#39;),
       Cat, kitty, mongoose;

   require(&#39;node-mimejs&#39;);

   mongoose = new Mime();
   // When mongoose.model is called, it returns a new class
   mongoose._spy(&#39;model&#39;, function(name, defn) {
       return this._createClass(function() {
       });
     });
   Cat = mongoose.model(&#39;Cat&#39;, { name: String });

   // Calling the class&#39;s constructor, will register a call against the &quot;Class&quot;
   // &quot;method&quot; in the mongoose Mime instance
   kitty = new Cat({ name: &#39;Zildjian&#39; });

   // Calling the child instance&#39;s functions will also register calls against
   // the mongoose Mime instance
   kitty.save(function (err) {
       if (err) {
           console.log(&#39;meow&#39;);
       }
   });

   // test that with these asserts
   describe(&#39;mongooseExample.js&#39;, function () {
       it(&#39;Should have created the model&#39;, function () {
           assert.ok(mongoose._wasCalledWithArguments(&#39;model&#39;, &#39;Cat&#39;, { name : String }),
             &#39;Should have called model&#39;);
       });

       it(&#39;Should have called the &quot;Cat&quot; constructor&#39;, function () {
           assert.equal(mongoose._getCallArguments(&#39;Class&#39;, 0)[0].name, &#39;Zildjian&#39;,
             &#39;Should have created a Zildjian cat&#39;);
       });

       it(&#39;Should have called the &quot;save&quot; method&#39;, function () {
           assert.equal(typeof mongoose._getCallArguments(&#39;save&#39;, 0)[0], &#39;function&#39;,
             &#39;Should have called with a callback&#39;);
       });
   });</code></pre>

    
</div>

            
                <a name="methods__getAllCallArguments"></a>
<div class="method item">
    <span class="foundat">
    
        
    
        <a href="../files/mime_mime.js.html#l289"><code>mime&#x2F;mime.js:289</code></a>
    </span>
    <h4 class="name"><span><code>_getAllCallArguments</code></span>( <code>name </code> ) </h4>
    <br>
    <p>Given a function name return the array of all the calls to that function.</p>

    
    <h5>Parameters:</h5>
    <ul class="params">
    
        <li>
        
            <code>name</code> <strong>&lt;String&gt;</strong>
        
        
        <ul>
<li>the name of the function</li>
</ul>

            
        </li>
    
    </ul>
    
    
    
    <br><div class="returns"><strong>Returns:</strong> &lt;Array&gt; </div>
    
    
    
        <h5>Example</h5>
        <pre class="code prettyprint"><code>   var mime = new Mime();
   mime.newFunction();
   mime.newFunction(1, 2, 3);
   assert.deepEqual(mime._getAllCallArguments(&#39;newFunction&#39;), [[], [1, 2, 3]],
       &#39;Should return array of argument arrays&#39;);</code></pre>

    
</div>

            
                <a name="methods__getCallArguments"></a>
<div class="method item">
    <span class="foundat">
    
        
    
        <a href="../files/mime_mime.js.html#l255"><code>mime&#x2F;mime.js:255</code></a>
    </span>
    <h4 class="name"><span><code>_getCallArguments</code></span>( <code>name, [index] </code> ) </h4>
    <br>
    <p>Given a function name and an index, returns the arguments of the call at
that index. It returns undefined if there was no call at that index.
It returns an empty array if there was a call with no arguments at that
index. If no index is supplied, the first call (0-index) will be assumed</p>

    
    <h5>Parameters:</h5>
    <ul class="params">
    
        <li>
        
            <code>name</code> <strong>&lt;String&gt;</strong>
        
        
        <ul>
<li>the name of the function</li>
</ul>

            
        </li>
    
        <li>
        
            <code>[index]</code> <strong>&lt;Integer&gt;</strong>
        
        
        <ul>
<li>which call&#39;s arguments to return</li>
</ul>

            
        </li>
    
    </ul>
    
    
    
    <br><div class="returns"><strong>Returns:</strong> &lt;Array&gt; </div>
    
    
    
        <h5>Example</h5>
        <pre class="code prettyprint"><code>   // The mime object was turned into a class factory using _createClass
   it(&#39;Should have called the child class\&#39;s constructor&#39;, function () {
       assert.equal(mime._getCallArguments(&#39;Class&#39;, 0)[0].name, &#39;Zildjian&#39;,
         &#39;Should have created a Zildjian cat&#39;);
   });</code></pre>

    
</div>

            
                <a name="methods__mockModule"></a>
<div class="method item">
    <span class="foundat">
    
        
    
        <a href="../files/mime_mime.js.html#l345"><code>mime&#x2F;mime.js:345</code></a>
    </span>
    <h4 class="name"><span><code>_mockModule</code></span>( <code>name, methods </code> ) </h4>
    <br>
    <p>Given a module name and a set of methods, create an exports structure for a module with
those methods and bind it to the this object. Put that structure into the global mocked
modules registry</p>

    
    <h5>Parameters:</h5>
    <ul class="params">
    
        <li>
        
            <code>name</code> <strong>&lt;String&gt;</strong>
        
        
        <ul>
<li>the name of the module as it will be required</li>
</ul>

            
        </li>
    
        <li>
        
            <code>methods</code> <strong>&lt;ArrayString | Object&gt;</strong>
        
        
        <ul>
<li>if a String, the name of the method to export and bind, if an Object, its attributes&#39; name will be exported, bound to the Mime instance and the function will also be called when the method is called</li>
</ul>

            
        </li>
    
    </ul>
    
    
    
    <br><div class="returns"><strong>Returns:</strong> &lt;Undefined&gt; </div>
    
    
    
        <h5>Example</h5>
        <pre class="code prettyprint"><code>   // In your test file, you use Mime.getMockedModuleMime to obtain a Mime object for the http module
   // This is required so that Node.js&#39;s module caching will not get in the way of multiple
   // modules requiring the same dependency
   httpMime = Mime.getMockedModuleMime(&#39;http&#39;);

   // Then tell the mime instance which symbols to export
   httpMime._mockModule(&#39;http&#39;, [&#39;setHeader&#39;, &#39;write&#39;, &#39;end&#39;]);

   // Then require the module with the dependency
   dependency = require(&#39;../src/dependency.js&#39;);

   // Now run the tests
   ...</code></pre>

    
</div>

            
                <a name="methods__spy"></a>
<div class="method item">
    <span class="foundat">
    
        
    
        <a href="../files/mime_mime.js.html#l178"><code>mime&#x2F;mime.js:178</code></a>
    </span>
    <h4 class="name"><span><code>_spy</code></span>( <code>name, [callback] </code> ) </h4>
    <br>
    <p>Create a function with a specific name that is bound to the Mime and
return this function. This function can then be passed into a test target
and will act as an argument Mime. You can test the arguments passed to
these calls in the same way as calls to a mocked object function</p>

    
    <h5>Parameters:</h5>
    <ul class="params">
    
        <li>
        
            <code>name</code> <strong>&lt;String&gt;</strong>
        
        
        <ul>
<li>the name you will use to test the arguments passed into the function when it was called</li>
</ul>

            
        </li>
    
        <li>
        
            <code>[callback]</code> <strong>&lt;Function&gt;</strong>
        
        
        <ul>
<li>optional parameter with a function to call when this method is called</li>
</ul>

            
        </li>
    
    </ul>
    
    
    
    <br><div class="returns"><strong>Returns:</strong> &lt;Function&gt; </div>
    
    
    
        <h5>Example</h5>
        <pre class="code prettyprint"><code>   // This will add a &quot;model&quot; function to the mime instance that mimics
   // Mongoose&#39;s model function
   mime._spy(&#39;model&#39;, function(name, schema) {
       return this._createClass(function() {
           // constructor function logic
           ...
       });
   });</code></pre>

    
</div>

            
                <a name="methods__unmockModule"></a>
<div class="method item">
    <span class="foundat">
    
        
    
        <a href="../files/mime_mime.js.html#l403"><code>mime&#x2F;mime.js:403</code></a>
    </span>
    <h4 class="name"><span><code>_unmockModule</code></span>( <code>name </code> ) </h4>
    <br>
    <p>Unregister the mocked exports for a module</p>

    
    <h5>Parameters:</h5>
    <ul class="params">
    
        <li>
        
            <code>name</code> <strong>&lt;String&gt;</strong>
        
        
        <ul>
<li>the name of the module to unmock</li>
</ul>

            
        </li>
    
    </ul>
    
    
    
    <br><div class="returns"><strong>Returns:</strong> &lt;Undefined&gt; </div>
    
    
    
</div>

            
                <a name="methods__wasCalledWithArguments"></a>
<div class="method item">
    <span class="foundat">
    
        
    
        <a href="../files/mime_mime.js.html#l213"><code>mime&#x2F;mime.js:213</code></a>
    </span>
    <h4 class="name"><span><code>_wasCalledWithArguments</code></span>( <code>name, [arguments] </code> ) </h4>
    <br>
    <p>Returns true if the function with the name passed in as the first argument
was called with the arguments passed in as the rest of the arguments.
Returns false under all other conditions</p>

    
    <h5>Parameters:</h5>
    <ul class="params">
    
        <li>
        
            <code>name</code> <strong>&lt;String&gt;</strong>
        
        
        <ul>
<li>the name of the function to test</li>
</ul>

            
        </li>
    
        <li>
        
            <code>[arguments]</code> <strong>&lt;Anything&gt;</strong>
        
        
        <ul>
<li>the other arguments to test</li>
</ul>

            
        </li>
    
    </ul>
    
    
    
    <br><div class="returns"><strong>Returns:</strong> &lt;Boolean&gt; </div>
    
    
    
        <h5>Example</h5>
        <pre class="code prettyprint"><code>   // The mime instance here was supplied as a mock for a mongoose module
   it(&#39;Should have created the model&#39;, function () {
       assert.ok(mime._wasCalledWithArguments(&#39;model&#39;, &#39;Cat&#39;, { name : String }),
         &#39;Should have called model&#39;);
   });</code></pre>

    
</div>

            
                <a name="methods_require"></a>
<div class="method item">
    <span class="foundat">
    
        
    
        <a href="../files/mime_mime.js.html#l115"><code>mime&#x2F;mime.js:115</code></a>
    </span>
    <h4 class="name"><span><code>require</code></span>( <code>name, require </code> ) </h4>
    <br>
    <p>Given a module name and the default require function, Mime.require will
return a mocked module for the name if one was registered with _mockModule
or it will defer the call to the require function passed in</p>

    
    <h5>Parameters:</h5>
    <ul class="params">
    
        <li>
        
            <code>name</code> <strong>&lt;String&gt;</strong>
        
        
        <ul>
<li>the module name</li>
</ul>

            
        </li>
    
        <li>
        
            <code>require</code> <strong>&lt;Function&gt;</strong>
        
        
        <ul>
<li>the default require function</li>
</ul>

            
        </li>
    
    </ul>
    
    
    
    <br><div class="returns"><strong>Returns:</strong> &lt;Object&gt; <ul>
<li>of exported module&#39;s symbols</li>
</ul>
</div>
    
    
    
        <h5>Example</h5>
        <pre class="code prettyprint"><code>   // In your module, use Mime.require for any dependency
   http = Mime.require(&#39;http&#39;, require);</code></pre>

    
</div>

            
            </div>
        
        
        
        
    </div>
</div>
</div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/js/tabs.js"></script>
<script type="text/javascript">
  var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
  document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
  var pageTracker = _gat._getTracker("UA-44989756-2");
  pageTracker._trackPageview();
} catch(err) {}
</script>
</body>
</html>
